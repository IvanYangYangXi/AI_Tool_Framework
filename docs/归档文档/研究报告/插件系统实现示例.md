# æ’ä»¶ç³»ç»Ÿæ ¸å¿ƒæŠ€æœ¯å®ç°ç¤ºä¾‹

> ğŸ“‹ **æ–‡æ¡£æ€§è´¨**ï¼šæŠ€æœ¯å®ç°å‚è€ƒ
> 
> æœ¬æ–‡æ¡£æä¾›äº†æ’ä»¶ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶çš„**ä»£ç å®ç°ç¤ºä¾‹**ï¼Œä½œä¸ºå¼€å‘å‚è€ƒã€‚
> 
> å½“å‰ç‰ˆæœ¬çš„å®é™…å®ç°è§ï¼š`src/core/` ç›®å½•

---

## 1. æ’ä»¶æ¥å£æ ‡å‡†åŒ–è®¾è®¡

### 1.1 åŸºç¡€æ’ä»¶æ¥å£å®šä¹‰

```python
from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, Any, Optional
from dataclasses import dataclass

class PluginType(Enum):
    """æ’ä»¶ç±»å‹æšä¸¾"""
    DCC_TOOL = "dcc_tool"          # DCCå·¥å…·æ’ä»¶
    UE_PLUGIN = "ue_plugin"        # UEå¼•æ“æ’ä»¶
    GENERAL_TOOL = "general_tool"  # é€šç”¨å·¥å…·æ’ä»¶
    EXTENSION = "extension"        # æ‰©å±•æ’ä»¶

@dataclass
class PluginMetadata:
    """æ’ä»¶å…ƒæ•°æ®"""
    plugin_id: str
    name: str
    version: str
    description: str
    author: str
    plugin_type: PluginType
    dependencies: list
    compatibility: Dict[str, str]

class PluginInterface(ABC):
    """æ’ä»¶åŸºç¡€æ¥å£ - å®šä¹‰æ‰€æœ‰æ’ä»¶å¿…é¡»å®ç°çš„æ–¹æ³•"""
    
    @property
    @abstractmethod
    def metadata(self) -> PluginMetadata:
        """è·å–æ’ä»¶å…ƒæ•°æ®"""
        pass
    
    @abstractmethod
    def initialize(self, config: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ’ä»¶"""
        pass
    
    @abstractmethod
    def execute(self, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œæ’ä»¶åŠŸèƒ½"""
        pass
    
    @abstractmethod
    def cleanup(self) -> None:
        """æ¸…ç†æ’ä»¶èµ„æº"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> Dict[str, Any]:
        """è·å–æ’ä»¶èƒ½åŠ›æè¿°"""
        pass
```

### 1.2 DCCè½¯ä»¶æ’ä»¶é€‚é…å™¨

```python
class DCCPluginAdapter(PluginInterface):
    """DCCè½¯ä»¶æ’ä»¶é€‚é…å™¨åŸºç±»"""
    
    def __init__(self, dcc_software: str):
        self.dcc_software = dcc_software
        self.is_connected = False
        
    @abstractmethod
    def connect_to_dcc(self) -> bool:
        """è¿æ¥åˆ°DCCè½¯ä»¶"""
        pass
    
    @abstractmethod
    def disconnect_from_dcc(self) -> None:
        """æ–­å¼€DCCè½¯ä»¶è¿æ¥"""
        pass
    
    @abstractmethod
    def execute_dcc_command(self, command: str, args: Dict[str, Any]) -> Any:
        """æ‰§è¡ŒDCCå‘½ä»¤"""
        pass

class MayaPluginAdapter(DCCPluginAdapter):
    """Mayaæ’ä»¶é€‚é…å™¨"""
    
    def __init__(self):
        super().__init__("maya")
        
    def connect_to_dcc(self) -> bool:
        try:
            import maya.cmds as cmds
            self.is_connected = True
            return True
        except ImportError:
            return False
    
    def execute_dcc_command(self, command: str, args: Dict[str, Any]) -> Any:
        if not self.is_connected:
            raise RuntimeError("æœªè¿æ¥åˆ°Maya")
            
        import maya.cmds as cmds
        cmd_func = getattr(cmds, command, None)
        if cmd_func:
            return cmd_func(**args)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„Mayaå‘½ä»¤: {command}")
```

## 2. æ’ä»¶å‘ç°ä¸åŠ è½½æœºåˆ¶

### 2.1 æ’ä»¶å‘ç°å™¨å®ç°

```python
import os
import importlib.util
import json
from pathlib import Path
from typing import List, Dict, Type

class PluginDiscoveryService:
    """æ’ä»¶å‘ç°æœåŠ¡"""
    
    def __init__(self, plugin_dirs: List[str]):
        self.plugin_dirs = plugin_dirs
        self.discovered_plugins: Dict[str, Type[PluginInterface]] = {}
        
    def discover_plugins(self) -> Dict[str, Type[PluginInterface]]:
        """å‘ç°æ‰€æœ‰å¯ç”¨æ’ä»¶"""
        for plugin_dir in self.plugin_dirs:
            self._scan_directory(plugin_dir)
        return self.discovered_plugins
    
    def _scan_directory(self, directory: str):
        """æ‰«æç›®å½•ä¸­çš„æ’ä»¶"""
        plugin_path = Path(directory)
        if not plugin_path.exists():
            return
            
        # æ‰«æPythonæ–‡ä»¶
        for py_file in plugin_path.glob("**/*.py"):
            self._load_plugin_from_file(py_file)
            
        # æ‰«ææ’ä»¶åŒ…
        for plugin_pkg in plugin_path.glob("**/plugin.json"):
            self._load_plugin_from_package(plugin_pkg.parent)
    
    def _load_plugin_from_file(self, file_path: Path):
        """ä»Pythonæ–‡ä»¶åŠ è½½æ’ä»¶"""
        try:
            spec = importlib.util.spec_from_file_location(
                file_path.stem, file_path
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # æŸ¥æ‰¾æ’ä»¶ç±»
            for attr_name in dir(module):
                attr = getattr(module, attr_name)
                if (isinstance(attr, type) and 
                    issubclass(attr, PluginInterface) and 
                    attr != PluginInterface):
                    plugin_id = f"{file_path.parent.name}.{attr_name}"
                    self.discovered_plugins[plugin_id] = attr
                    break
                    
        except Exception as e:
            print(f"åŠ è½½æ’ä»¶å¤±è´¥ {file_path}: {e}")
    
    def _load_plugin_from_package(self, package_path: Path):
        """ä»æ’ä»¶åŒ…åŠ è½½æ’ä»¶"""
        try:
            config_file = package_path / "plugin.json"
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            plugin_id = config.get('id')
            entry_module = config.get('entry_module')
            
            if plugin_id and entry_module:
                module_path = package_path / f"{entry_module}.py"
                spec = importlib.util.spec_from_file_location(
                    entry_module, module_path
                )
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # è·å–æ’ä»¶ç±»
                plugin_class = getattr(module, config.get('plugin_class'), None)
                if plugin_class and issubclass(plugin_class, PluginInterface):
                    self.discovered_plugins[plugin_id] = plugin_class
                    
        except Exception as e:
            print(f"åŠ è½½æ’ä»¶åŒ…å¤±è´¥ {package_path}: {e}")
```

### 2.2 åŠ¨æ€åŠ è½½å™¨å®ç°

```python
import threading
from concurrent.futures import ThreadPoolExecutor
from typing import Optional, Callable

class PluginLoader:
    """æ’ä»¶åŠ¨æ€åŠ è½½å™¨"""
    
    def __init__(self):
        self.loaded_plugins: Dict[str, PluginInterface] = {}
        self.loading_lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=4)
        
    def load_plugin(self, plugin_id: str, 
                   plugin_class: Type[PluginInterface],
                   config: Dict[str, Any] = None) -> Optional[PluginInterface]:
        """åŠ è½½æŒ‡å®šæ’ä»¶"""
        with self.loading_lock:
            if plugin_id in self.loaded_plugins:
                return self.loaded_plugins[plugin_id]
            
            try:
                # åˆ›å»ºæ’ä»¶å®ä¾‹
                plugin_instance = plugin_class()
                
                # åˆå§‹åŒ–æ’ä»¶
                if plugin_instance.initialize(config or {}):
                    self.loaded_plugins[plugin_id] = plugin_instance
                    return plugin_instance
                else:
                    print(f"æ’ä»¶åˆå§‹åŒ–å¤±è´¥: {plugin_id}")
                    return None
                    
            except Exception as e:
                print(f"åŠ è½½æ’ä»¶å¼‚å¸¸ {plugin_id}: {e}")
                return None
    
    def unload_plugin(self, plugin_id: str) -> bool:
        """å¸è½½æ’ä»¶"""
        with self.loading_lock:
            if plugin_id in self.loaded_plugins:
                try:
                    self.loaded_plugins[plugin_id].cleanup()
                    del self.loaded_plugins[plugin_id]
                    return True
                except Exception as e:
                    print(f"å¸è½½æ’ä»¶å¼‚å¸¸ {plugin_id}: {e}")
                    return False
            return False
    
    def async_load_plugin(self, plugin_id: str,
                         plugin_class: Type[PluginInterface],
                         callback: Callable[[Optional[PluginInterface]], None],
                         config: Dict[str, Any] = None):
        """å¼‚æ­¥åŠ è½½æ’ä»¶"""
        future = self.executor.submit(
            self.load_plugin, plugin_id, plugin_class, config
        )
        future.add_done_callback(
            lambda f: callback(f.result())
        )
```

## 3. é…ç½®ç®¡ç†ç³»ç»Ÿ

### 3.1 åˆ†å±‚é…ç½®ç®¡ç†

```python
import yaml
import json
from pathlib import Path
from typing import Dict, Any, Optional

class ConfigurationManager:
    """åˆ†å±‚é…ç½®ç®¡ç†å™¨"""
    
    def __init__(self, config_base_path: str):
        self.base_path = Path(config_base_path)
        self.system_config = {}
        self.user_config = {}
        self.plugin_configs = {}
        
    def load_all_configs(self):
        """åŠ è½½æ‰€æœ‰å±‚çº§é…ç½®"""
        self.system_config = self._load_system_config()
        self.user_config = self._load_user_config()
        self.plugin_configs = self._load_plugin_configs()
    
    def _load_system_config(self) -> Dict[str, Any]:
        """åŠ è½½ç³»ç»Ÿé…ç½®"""
        system_config_file = self.base_path / "system.yaml"
        if system_config_file.exists():
            with open(system_config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        return {}
    
    def _load_user_config(self) -> Dict[str, Any]:
        """åŠ è½½ç”¨æˆ·é…ç½®"""
        user_config_file = self.base_path / "user.yaml"
        if user_config_file.exists():
            with open(user_config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        return {}
    
    def _load_plugin_configs(self) -> Dict[str, Dict[str, Any]]:
        """åŠ è½½æ’ä»¶é…ç½®"""
        plugin_configs = {}
        plugins_config_dir = self.base_path / "plugins"
        
        if plugins_config_dir.exists():
            for config_file in plugins_config_dir.glob("*.yaml"):
                plugin_id = config_file.stem
                with open(config_file, 'r', encoding='utf-8') as f:
                    plugin_configs[plugin_id] = yaml.safe_load(f)
        
        return plugin_configs
    
    def get_plugin_config(self, plugin_id: str) -> Dict[str, Any]:
        """è·å–æ’ä»¶é…ç½®ï¼ˆåˆå¹¶ä¼˜å…ˆçº§ï¼šç”¨æˆ· > æ’ä»¶ > ç³»ç»Ÿï¼‰"""
        config = {}
        
        # ç³»ç»Ÿé…ç½®ä¸ºåŸºç¡€
        config.update(self.system_config.get('default_plugin_config', {}))
        
        # æ’ä»¶é»˜è®¤é…ç½®è¦†ç›–
        if plugin_id in self.plugin_configs:
            config.update(self.plugin_configs[plugin_id])
        
        # ç”¨æˆ·é…ç½®æœ€ç»ˆè¦†ç›–
        user_plugin_config = self.user_config.get('plugins', {}).get(plugin_id, {})
        config.update(user_plugin_config)
        
        return config
```

### 3.2 SDDæ ¼å¼è§£æå™¨

```python
import jsonschema
from typing import Dict, Any

class SDDParser:
    """SDD (Software Design Document) è§£æå™¨"""
    
    # SDD JSON Schemaå®šä¹‰
    SDD_SCHEMA = {
        "type": "object",
        "properties": {
            "tool_info": {
                "type": "object",
                "properties": {
                    "name": {"type": "string"},
                    "version": {"type": "string"},
                    "type": {"type": "string", "enum": ["dcc", "ue_engine", "general"]},
                    "category": {"type": "string"},
                    "description": {"type": "string"}
                },
                "required": ["name", "version", "type"]
            },
            "dependencies": {
                "type": "object",
                "properties": {
                    "required_tools": {"type": "array", "items": {"type": "string"}},
                    "compatible_versions": {"type": "array", "items": {"type": "string"}}
                }
            },
            "configuration": {
                "type": "object",
                "properties": {
                    "input_params": {"type": "array"},
                    "output_params": {"type": "array"}
                }
            },
            "execution": {
                "type": "object",
                "properties": {
                    "entry_point": {"type": "string"},
                    "command_line": {"type": "string"},
                    "timeout": {"type": "integer"},
                    "memory_limit": {"type": "string"}
                }
            }
        },
        "required": ["tool_info"]
    }
    
    @classmethod
    def validate_sdd(cls, sdd_content: Dict[str, Any]) -> bool:
        """éªŒè¯SDDæ ¼å¼"""
        try:
            jsonschema.validate(sdd_content, cls.SDD_SCHEMA)
            return True
        except jsonschema.ValidationError as e:
            print(f"SDDéªŒè¯å¤±è´¥: {e.message}")
            return False
    
    @classmethod
    def parse_sdd_to_config(cls, sdd_content: Dict[str, Any]) -> Dict[str, Any]:
        """å°†SDDè½¬æ¢ä¸ºæ’ä»¶é…ç½®"""
        if not cls.validate_sdd(sdd_content):
            raise ValueError("æ— æ•ˆçš„SDDæ ¼å¼")
        
        config = {
            "plugin_metadata": {
                "name": sdd_content["tool_info"]["name"],
                "version": sdd_content["tool_info"]["version"],
                "description": sdd_content["tool_info"].get("description", ""),
                "type": sdd_content["tool_info"]["type"]
            },
            "dependencies": sdd_content.get("dependencies", {}),
            "parameters": {
                "input": sdd_content.get("configuration", {}).get("input_params", []),
                "output": sdd_content.get("configuration", {}).get("output_params", [])
            },
            "execution": sdd_content.get("execution", {})
        }
        
        return config
```

## 4. æƒé™æ§åˆ¶ç³»ç»Ÿ

### 4.1 æƒé™ç®¡ç†å™¨

```python
from enum import Enum
from dataclasses import dataclass
from typing import Set, List

class PermissionLevel(Enum):
    """æƒé™ç­‰çº§"""
    READ_ONLY = "read_only"
    BASIC = "basic" 
    ADVANCED = "advanced"
    ADMIN = "admin"

@dataclass
class Permission:
    """æƒé™å®šä¹‰"""
    name: str
    level: PermissionLevel
    description: str

class PermissionManager:
    """æƒé™ç®¡ç†å™¨"""
    
    def __init__(self):
        self.permissions: Dict[str, Permission] = {}
        self.user_permissions: Dict[str, Set[str]] = {}
        self.role_permissions: Dict[str, Set[str]] = {}
        
    def register_permission(self, permission: Permission):
        """æ³¨å†Œæƒé™"""
        self.permissions[permission.name] = permission
    
    def assign_permission_to_user(self, user_id: str, permission_name: str):
        """ä¸ºç”¨æˆ·åˆ†é…æƒé™"""
        if permission_name in self.permissions:
            if user_id not in self.user_permissions:
                self.user_permissions[user_id] = set()
            self.user_permissions[user_id].add(permission_name)
    
    def check_permission(self, user_id: str, permission_name: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰æŒ‡å®šæƒé™"""
        user_perms = self.user_permissions.get(user_id, set())
        return permission_name in user_perms
    
    def get_user_permissions(self, user_id: str) -> List[Permission]:
        """è·å–ç”¨æˆ·æ‰€æœ‰æƒé™"""
        user_perm_names = self.user_permissions.get(user_id, set())
        return [self.permissions[name] for name in user_perm_names 
                if name in self.permissions]

# é¢„å®šä¹‰æƒé™
DEFAULT_PERMISSIONS = [
    Permission("plugin.install", PermissionLevel.ADMIN, "å®‰è£…æ’ä»¶"),
    Permission("plugin.uninstall", PermissionLevel.ADMIN, "å¸è½½æ’ä»¶"),
    Permission("plugin.execute", PermissionLevel.BASIC, "æ‰§è¡Œæ’ä»¶"),
    Permission("config.modify", PermissionLevel.ADVANCED, "ä¿®æ”¹é…ç½®"),
    Permission("system.monitor", PermissionLevel.READ_ONLY, "ç›‘æ§ç³»ç»ŸçŠ¶æ€")
]
```

### 4.2 æ²™ç®±æ‰§è¡Œç¯å¢ƒ

```python
import sys
from contextlib import contextmanager
from typing import Any, Dict

class SandboxEnvironment:
    """æ²™ç®±æ‰§è¡Œç¯å¢ƒ"""
    
    def __init__(self, resource_limits: Dict[str, Any] = None):
        self.resource_limits = resource_limits or {}
        self.original_modules = sys.modules.copy()
        
    @contextmanager
    def isolated_execution(self):
        """éš”ç¦»æ‰§è¡Œä¸Šä¸‹æ–‡"""
        # ä¿å­˜å½“å‰çŠ¶æ€
        original_path = sys.path[:]
        original_modules = sys.modules.copy()
        
        try:
            # è®¾ç½®èµ„æºé™åˆ¶
            self._apply_resource_limits()
            
            # åˆ›å»ºéš”ç¦»çš„æ¨¡å—ç©ºé—´
            restricted_modules = self._create_restricted_modules()
            sys.modules.update(restricted_modules)
            
            yield
            
        finally:
            # æ¢å¤åŸå§‹çŠ¶æ€
            sys.path[:] = original_path
            sys.modules.clear()
            sys.modules.update(original_modules)
            self._release_resource_limits()
    
    def _apply_resource_limits(self):
        """åº”ç”¨èµ„æºé™åˆ¶"""
        import resource
        
        if 'memory' in self.resource_limits:
            memory_limit = self.resource_limits['memory']
            resource.setrlimit(resource.RLIMIT_AS, (memory_limit, memory_limit))
        
        if 'cpu_time' in self.resource_limits:
            cpu_limit = self.resource_limits['cpu_time']
            resource.setrlimit(resource.RLIMIT_CPU, (cpu_limit, cpu_limit))
    
    def _release_resource_limits(self):
        """é‡Šæ”¾èµ„æºé™åˆ¶"""
        import resource
        # æ¢å¤é»˜è®¤é™åˆ¶
        resource.setrlimit(resource.RLIMIT_AS, resource.RLIM_INFINITY)
        resource.setrlimit(resource.RLIMIT_CPU, resource.RLIM_INFINITY)
    
    def _create_restricted_modules(self) -> Dict[str, Any]:
        """åˆ›å»ºå—é™çš„æ¨¡å—ç¯å¢ƒ"""
        restricted = {}
        
        # åªå…è®¸å®‰å…¨çš„å†…ç½®æ¨¡å—
        safe_modules = ['sys', 'os', 'json', 'math']
        for module_name in safe_modules:
            if module_name in sys.modules:
                restricted[module_name] = sys.modules[module_name]
        
        return restricted
```

## 5. äº‹ä»¶æ€»çº¿å®ç°

### 5.1 äº‹ä»¶ç³»ç»Ÿæ ¸å¿ƒ

```python
from typing import Dict, List, Callable, Any
import asyncio
import threading
from dataclasses import dataclass
from enum import Enum

class EventType(Enum):
    """äº‹ä»¶ç±»å‹æšä¸¾"""
    PLUGIN_LOADED = "plugin_loaded"
    PLUGIN_UNLOADED = "plugin_unloaded"
    PLUGIN_EXECUTED = "plugin_executed"
    CONFIG_CHANGED = "config_changed"
    SYSTEM_ERROR = "system_error"

@dataclass
class Event:
    """äº‹ä»¶æ•°æ®ç»“æ„"""
    event_type: EventType
    source: str
    data: Dict[str, Any]
    timestamp: float

class EventBus:
    """äº‹ä»¶æ€»çº¿å®ç°"""
    
    def __init__(self):
        self.listeners: Dict[EventType, List[Callable]] = {}
        self.event_queue = asyncio.Queue()
        self.running = False
        self.event_loop = None
        
    def subscribe(self, event_type: EventType, listener: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.listeners:
            self.listeners[event_type] = []
        self.listeners[event_type].append(listener)
    
    def unsubscribe(self, event_type: EventType, listener: Callable):
        """å–æ¶ˆè®¢é˜…äº‹ä»¶"""
        if event_type in self.listeners:
            self.listeners[event_type].remove(listener)
    
    def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        if self.event_loop and self.running:
            asyncio.run_coroutine_threadsafe(
                self._handle_event(event), self.event_loop
            )
        else:
            # åŒæ­¥å¤„ç†
            self._dispatch_event(event)
    
    async def _handle_event(self, event: Event):
        """å¼‚æ­¥å¤„ç†äº‹ä»¶"""
        await self.event_queue.put(event)
        self._dispatch_event(event)
    
    def _dispatch_event(self, event: Event):
        """åˆ†å‘äº‹ä»¶ç»™ç›‘å¬å™¨"""
        if event.event_type in self.listeners:
            for listener in self.listeners[event.event_type]:
                try:
                    listener(event)
                except Exception as e:
                    print(f"äº‹ä»¶å¤„ç†å¼‚å¸¸: {e}")
    
    def start_event_loop(self):
        """å¯åŠ¨äº‹ä»¶å¾ªç¯"""
        self.running = True
        self.event_loop = asyncio.new_event_loop()
        
        def run_loop():
            asyncio.set_event_loop(self.event_loop)
            self.event_loop.run_forever()
            
        thread = threading.Thread(target=run_loop, daemon=True)
        thread.start()
    
    def stop_event_loop(self):
        """åœæ­¢äº‹ä»¶å¾ªç¯"""
        self.running = False
        if self.event_loop:
            self.event_loop.call_soon_threadsafe(self.event_loop.stop)
```

è¿™äº›å®ç°ç¤ºä¾‹å±•ç¤ºäº†æ’ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹ï¼ŒåŒ…æ‹¬æ ‡å‡†åŒ–æ¥å£è®¾è®¡ã€åŠ¨æ€å‘ç°åŠ è½½ã€åˆ†å±‚é…ç½®ç®¡ç†ã€æƒé™æ§åˆ¶å’Œäº‹ä»¶é€šä¿¡ç­‰å…³é”®åŠŸèƒ½ã€‚æ¯ä¸ªç»„ä»¶éƒ½éµå¾ªäº†è‰¯å¥½çš„è½¯ä»¶å·¥ç¨‹åŸåˆ™ï¼Œå¯ä»¥ä½œä¸ºå®é™…å¼€å‘çš„å‚è€ƒåŸºç¡€ã€‚